# Technical Specification: PolyWeather Tactical Dashboard
**Version:** 2.0.0
**Domain:** High-Frequency Prediction Market Trading
**Resolution Source:** Wunderground (via Aviation/METAR Network)

## 1. System Overview
The PolyWeather Tactical Dashboard is a client-side application designed to visualize hidden market factors ("Alpha") and execute low-latency orders for binary weather contracts. It functions as a **Heads-Up Display (HUD)**, prioritizing data freshness and execution speed over automation.

## 2. Data Interface Layer

### 2.1 Primary Data Source
The system relies on the US National Weather Service (NOAA) Aviation Weather Center.
*   **Protocol:** HTTP GET
*   **Endpoint:** `https://aviationweather.gov/api/data/metar`
*   **Required Parameters:**
    *   `ids`: Station ICAO Code (e.g., `RKSI` for Incheon, `EGLL` for Heathrow).
    *   `format`: `json` (for parsing efficiency).
    *   `hours`: `24` (Required to calculate the "Midnight Floor").

### 2.2 Data Model
The application must parse the JSON response into an ordered **Time-Series Collection** containing:
```json
[
  {
    "timestamp_utc": "ISO-8601 String",
    "temperature_c": Float,
    "raw_observation": String
  }
]
```

---

## 3. Core Business Logic (The Alpha)

The competitive advantage of this system relies on three specific algorithms.

### 3.1 Algorithm: The Midnight High Floor
*Objective:* Determine the "Phantom High" â€” the highest temperature recorded since 00:00 Local Time, which acts as the minimum settlement value for the contract.

**Pseudocode:**
```text
FUNCTION GetMidnightFloor(history_data, utc_offset_hours):
    current_utc = GetCurrentTimeUTC()
    current_local = current_utc + utc_offset_hours
    
    // Determine the start of the current local day
    start_of_day_local = Date(current_local.Year, current_local.Month, current_local.Day, 00, 00, 00)
    start_of_day_utc = start_of_day_local - utc_offset_hours
    
    // Filter for readings belonging to "Today"
    todays_readings = FILTER history_data WHERE entry.timestamp_utc >= start_of_day_utc
    
    IF todays_readings IS EMPTY:
        RETURN Error("No Data For Today")
    
    RETURN Max(todays_readings.temperature_c)
```

### 3.2 Algorithm: Heating Velocity
*Objective:* Calculate the rate of warming ($^\circ C/hr$) to identify stalls (sell signals) or spikes (buy signals).

**Pseudocode:**
```text
FUNCTION CalculateVelocity(history_data):
    latest = history_data[0]
    previous = history_data[1]
    
    temp_diff = latest.temperature_c - previous.temperature_c
    time_diff_hours = (latest.timestamp_utc - previous.timestamp_utc) in Hours
    
    RETURN (temp_diff / time_diff_hours)
```

### 3.3 Algorithm: Gap-to-Danger
*Objective:* Real-time risk visualization.
**Logic:** `Gap = Danger_Threshold_Temp - Current_Temp`
*   *Visual Output:* If `Gap <= 0.5`, display Alert Color (Red).

---

## 4. User Interface Architecture

### 4.1 Layout Wireframe
The UI is divided into three functional zones:

**Zone A: The HUD (Top Row)**
*   **Metric 1:** Current Temperature (Large Font).
*   **Metric 2:** Midnight Floor (Large Font). *Logic: Highlight RED if Midnight Floor > Current Temp.*
*   **Metric 3:** Local Time (Digital Clock).
*   **Control:** "Force Refresh" Button.

**Zone B: Analysis (Middle)**
*   **Chart:** Line graph X=Local Time, Y=Temperature.
*   **Overlays:**
    *   Horizontal Dotted Line @ `Midnight Floor Value`.
    *   Horizontal Dotted Line @ `Target Forecast Value`.

**Zone C: Execution Desk (Bottom)**
*   **Column 1 (Cold Thesis):** Input for Token ID + Buy/Sell Buttons.
*   **Column 2 (Target Thesis):** Input for Token ID + Buy/Sell Buttons.
*   **Column 3 (Hot/Hedge Thesis):** Input for Token ID + Buy/Sell Buttons.

---

## 5. Execution Engine

### 5.1 Order Construction
To ensure fill probability in a thin order book, the system uses **Aggressive Limit Orders** rather than Market Orders.

**Pseudocode for "Snipe" (Buy):**
```text
FUNCTION Snipe(token_id, quantity):
    order_book = FetchOrderBook(token_id)
    best_ask = order_book.asks[0].price
    
    // Cross the spread to guarantee entry
    limit_price = best_ask + SLIPPAGE_TOLERANCE (e.g., 0.05)
    
    // Sanity Check
    IF limit_price > 0.99:
        RETURN Error("Price too high")
        
    SignAndSubmitOrder(Side: BUY, Price: limit_price, Size: quantity)
```

**Pseudocode for "Dump" (Sell):**
```text
FUNCTION Dump(token_id, quantity):
    order_book = FetchOrderBook(token_id)
    best_bid = order_book.bids[0].price
    
    // Undercut the bid to exit immediately
    limit_price = best_bid - SLIPPAGE_TOLERANCE (e.g., 0.05)
    
    SignAndSubmitOrder(Side: SELL, Price: limit_price, Size: quantity)
```

### 5.2 Security Model
*   **Key Management:** Private keys (Ethereum/Polygon format) must be ingested via user input field at runtime.
*   **Storage:** Keys must exist in **Volatile Memory Only** (RAM).
*   **Persistence:** Never write keys to disk, local storage, or config files.

---

## 6. Configuration Parameters
The system requires a configuration object to adapt to different airports:

| Parameter | Type | Description |
| :--- | :--- | :--- |
| `STATION_ID` | String | ICAO Code (e.g., "RKSI") |
| `UTC_OFFSET` | Integer | Local timezone offset (e.g., 9) |
| `TARGET_TEMP` | Float | The forecasted daily high (e.g., -2.0) |
| `DANGER_TEMP` | Float | The temperature that breaks the thesis (e.g., -1.0) |